下面给出**“多目标输入 → 多目标输出”**的**最小改动方案**：

- ① 输入端：一条 JSON/ROS 消息里**带多个 track**  
- ② 引擎端：`engine` **循环处理每个 track**，**输出字典 key=track_id**  
- ③ 输出端：**保持原格式**，只是**外层再包一层 `{track_id: 结果}`**

---

### ✅ 一、输入格式（多目标包）

#### 1. JSON 示例（单包 20 Hz）

```json
{
  "timestamp": 1710000000.05,
  "tracks": [
    {"id": "enemy_01", "lat": 29.9, "lon": 126.6, "spd": 120, "heading": 70, "alt": 100},
    {"id": "enemy_02", "lat": 29.91, "lon": 126.61, "spd": 110, "heading": 80, "alt": 95}
  ]
}
```

#### 2. ROS 示例（自定义消息）

```yaml
Header header
Track[] tracks
---
string id
float64 lat
float64 lon
float64 spd
float64 heading
float64 alt
```

---

### ✅ 二、引擎侧（最小改动）

在 `engine_instant.py` **新增一个入口**：

```python
def update_multi(self, packet):
    """
    packet = {
      "timestamp": float,
      "tracks": [ {id, lat, lon, spd, heading, alt}, ... ]
    }
    返回：{track_id: 瞬时结果 dict}
    """
    out = {}
    for trk in packet['tracks']:
        track_id = trk['id']
        self.update_obs(track_id, packet['timestamp'],
                        trk['lat'], trk['lon'], trk['spd'],
                        trk['heading'], trk.get('alt'))
        out[track_id] = self.predict(track_id)[0]   # 瞬时
    return out
```

**长时同理**：

```python
def update_long_multi(self, packet):
    out = {}
    for trk in packet['tracks']:
        track_id = trk['id']
        self.long_engine.update_obs(track_id, packet['timestamp'],
                                    trk['lat'], trk['lon'], trk['spd'],
                                    trk['heading'], trk.get('alt'))
        out[track_id] = self.long_engine.predict(track_id, [300, 600, 1800, 3600])
    return out
```

---

### ✅ 三、输出格式（多目标包）

#### 1. 瞬时（20 Hz）

```json
{
  "timestamp": 1710000000.05,
  "tracks": {
    "enemy_01": {
      "heading_deg_mean": 71.3,
      "maneuver": "right_turn",
      "next_lat": 29.9001,
      ...
    },
    "enemy_02": {
      "heading_deg_mean": 81.2,
      "maneuver": "straight",
      ...
    }
  }
}
```

#### 2. 长时（1 Hz）

```json
{
  "timestamp": 1710000001.0,
  "tracks": {
    "enemy_01": {
      "300": {"most_likely_maneuver": "right_turn", "maneuver_probs": {...}, ...},
      "600": {...},
      "1800": {...},
      "3600": {...}
    },
    "enemy_02": { ... }
  }
}
```

---

### ✅ 四、ROS 节点（完整模板）

```python
#!/usr/bin/env python3
import rospy, json
from your_msg.msg import MultiTrack, MultiTrackResult
from engine_instant import Model6Engine

engine = Model6Engine(converter, costmap, goals)
pub = rospy.Publisher('/model6/multi_result', MultiTrackResult, queue_size=1)

def cb_multi(msg):
    pkt = {"timestamp": msg.header.stamp.to_sec(),
           "tracks": [{"id": t.id, "lat": t.lat, "lon": t.lon,
                       "spd": t.spd, "heading": t.heading, "alt": t.alt}
                      for t in msg.tracks]}
    out = engine.update_multi(pkt)
    # 封装 ROS 消息
    result = MultiTrackResult()
    result.header.stamp = msg.header.stamp
    result.json = json.dumps(out)
    pub.publish(result)

rospy.init_node('model6_multi')
rospy.Subscriber('/sensor/multi_track', MultiTrack, cb_multi)
rospy.spin()
```

---

### ✅ 五、批量文件（CSV 多目标）

```python
import pandas as pd
df = pd.read_csv('multi_track.csv')   # 字段：t,track_id,lat,lon,spd,heading,alt
# 按时间分组
for t, g in df.groupby('t'):
    packet = {"timestamp": t, "tracks": g.to_dict(orient='records')}
    out_inst = engine_instant.update_multi(packet)
    out_long = engine_long.update_long_multi(packet)
    save_csv(t, out_inst, out_long)
```

---

### ✅ 六、一键切换（单↔多）

在 `main()` 里加环境变量：

```python
import os
if os.getenv('MODEL6_MULTI') == '1':
    handle = handle_multi        # 多目标入口
else:
    handle = handle_single       # 旧单目标
```

运行多目标：

```bash
export MODEL6_MULTI=1
python your_node.py
```

---

### ✅ 七、一句话总结

> **输入包加 `tracks[]` → 引擎循环 `update_obs` 每个 `id` → 输出字典 key=track_id**；  
> **瞬时 20 Hz 实时标签，长时 1 s 批量意图**，**单/多目标一键切换**，**算法零改动**！